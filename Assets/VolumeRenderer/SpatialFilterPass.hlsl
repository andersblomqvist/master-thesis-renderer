#ifndef SPATIAL_FILTER_PASS
#define SPATIAL_FILTER_PASS

#define UNFILTERED 1
#define GAUSSIAN   2
#define BOX        3

float4 gaussian_blur(TEXTURE2D_X(tex), float2 uv)
{
    // Replace this, was auto generated by AI
    float4 color = float4(0, 0, 0, 0);
    float weights[9] = {
        0.0625, 0.125, 0.0625,
        0.125,  0.25,  0.125,
        0.0625, 0.125, 0.0625
    };
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            float2 offset = float2(i, j) / _ScreenParams.xy;
            color += SAMPLE_TEXTURE2D_X(tex, s_linear_clamp_sampler, uv + offset) * weights[(i + 1) * 3 + j + 1];
        }
    }
    return color;
}

float4 box_three_filter(TEXTURE2D_X(tex), float2 uv)
{
    float4 result = 0;
    float2 texel_size = float2(1.0 / _ScreenSize.x, 1.0 / _ScreenSize.y);

    int radius = 1;
    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            float2 offset = float2(x, y) * texel_size;
            result += SAMPLE_TEXTURE2D_X(tex, s_linear_clamp_sampler, uv + offset);
        }
    }
    return result / 9.0;
}

float4 unfiltered(TEXTURE2D_X(tex), float2 uv)
{
    float4 color = SAMPLE_TEXTURE2D_X(tex, s_linear_clamp_sampler, uv);
    return color;
}

// Called from TemporalFilterPass.hlsl
float4 SpatialPass(TEXTURE2D_X(tex), float2 uv, int active_filter)
{
    if (active_filter == GAUSSIAN)
    {
        return gaussian_blur(tex, uv);
    }
    else if (active_filter == BOX)
    {
        return box_three_filter(tex, uv);
    }

    return unfiltered(tex, uv);
}

#endif // SPATIAL_FILTER_PASS